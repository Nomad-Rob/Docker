This will show how to do Multiple Containers for a project

## Requirements
- Docker application installed on your host machine
- Docker account
- Docker Compose installed
- IDE (VSCode or whatever you prefer)
- Makefile extensions (optional) but used in this repo

## Usage
This Docker Compose file is designed to create a multi-container Docker application with three main services: `frontend`, `backend`,`database`, and `loadbalance `. Each service is configured to meet specific requirements of a typical web application stack.
1. Place the Docker Compose file in the root of your project directory.
2. Ensure you have a `frontend`, `backend`, `database`, and directory.
3. Build the Docker image: `docker-compose build`
4. Run the container: `docker-compose up`
5. Access your application at `http://localhost:5173`

## Docker Compose
This file will show how to run multiple containers with docker compose. Docker compose is a tool that allows you to run multiple containers at once. This is useful if you have an application that requires multiple containers to run. For example if you have a web application that requires a database and a web server. You can use docker compose to run both containers at once. This will allow you to run your application locally without having to deploy it to a server. This is useful for testing and development purposes.

# Docker Compose Configuration Explanation

This Docker Compose file is designed to create a multi-container Docker application with three main services: `frontend`, `backend`, and `database`. Each service is configured to meet specific requirements of a typical web application stack.

## Services Overview

### Frontend Service
- **Build Context and Environment**: The frontend service is built using the Dockerfile in the `./frontend` directory. The build argument `NODE_ENV` is set to `development`, indicating that the build context is for development purposes.
- **Port Mapping**: The service is configured to expose port 5173 on both the host and the container, allowing access to the frontend application.
- **Volumes**: A volume is mapped from the host's `./frontend` directory to `/app` in the container. This allows for live updating of the frontend code without needing to rebuild the image.
- **Restart Policy**: The service uses `unless-stopped` as its restart policy, meaning it will always restart unless explicitly stopped by the user.

### Backend Service
- **Build Context and Environment**: Similar to the frontend, the backend service uses the Dockerfile in the `./backend` directory with `NODE_ENV` set to `development`.
- **Port Mapping**: Port 3001 is exposed on both the host and the container for backend service access.
- **Volumes**: The `./backend` directory on the host is mapped to `/app` in the container, enabling live code updates.
- **Restart Policy**: The backend service also restarts automatically unless it's manually stopped.

### Database Service
- **Environment Variables**: The database service, using the `postgres:latest` image, is configured with environment variables for setting up the Postgres user, password, and database name.
- **Port Mapping**: Port 5432 is exposed, allowing database access from the host.
- **Volumes**: The `./pg_data` directory on the host is mapped to `/var/lib/postgresql/data` in the container. This mapping ensures data persistence across container restarts.
- **Restart Policy**: The database service will automatically restart unless stopped.

## Understanding Docker Volumes
## Docker Volumes

Docker volumes are used for managing persistent data generated by and used by Docker containers. Here are key points about Docker volumes:

### Data Persistence

Volumes provide a way to persist data generated by and used by Docker containers. When containers are removed, the volume remains intact.

### Data Sharing

Volumes can be shared and reused among multiple containers. They allow you to share data between a container and the host machine.

### Storage Independence

Volumes are managed outside the lifecycle of a container, making them a reliable choice for storing data. They are stored in a part of the host filesystem which is managed by Docker (/var/lib/docker/volumes/ on Linux).

### Non-Docker Processes

Data in volumes is accessible to non-Docker processes, meaning you can use system tools to manipulate them.

### Types of Volumes

- Named Volumes: Identified by a name and easier to work with.
- Anonymous Volumes: Created without a name and identified by their ID.

### Use Cases

- Ideal for storing database files, configurations, large datasets, and logs.
- Useful for applications that need to save state, like WordPress or MySQL.

### Volume Drivers

Docker supports multiple volume drivers, allowing volumes to be hosted on remote hosts or cloud providers. Drivers can be specified when creating a volume.

### Backup and Migration

Volumes can be backed up or moved from one machine to another, providing flexibility for data management.

### Performance

They offer better performance for storing and accessing data compared to bind mounts.

### Security

Docker volumes are more secure than bind mounts as they donâ€™t allow direct access to the host file system.

## NGINX Configuration

### What is NGINX?
NGINX is a popular open-source web server and reverse proxy server. It is known for its high performance, stability, and low resource consumption. NGINX is widely used to serve web content, manage traffic, and handle load balancing.

### NGINX Configuration in Docker
In this project, NGINX is used as a reverse proxy server to route requests to the frontend and backend services. The NGINX configuration file is located at `./nginx/nginx.conf` and is mounted into the NGINX container at `/etc/nginx/nginx.conf`.

### Key Configuration Points
- **Server Blocks**: The NGINX configuration file contains two server blocks, one for the frontend service and one for the backend service. Each server block defines the location of the service and the port it is running on.
